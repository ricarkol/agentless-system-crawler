#!/usr/bin/env python2.7

from __future__ import print_function
import os
import sys
import json
import logging
import usndb



DIRNAME = os.path.abspath(os.path.dirname(__file__))

def compare_versions(os_distro, pkg_ver1, pkg_ver2, logger):
    import rpm
    from rpmUtils.miscutils import stringToVersion
    import apt_pkg
    apt_pkg.init()
    #logger.info('os_distro={}, pkg_ver1={}, pkg_ver2={}'.format(os_distro, pkg_ver1, pkg_ver2)) 
    
    def rpm_compare(pkg_ver1, pkg_ver2):
        return rpm.labelCompare(
            stringToVersion(pkg_ver1), 
            stringToVersion(pkg_ver2))
    
    def apt_compare(pkg_ver1, pkg_ver2):
        return apt_pkg.version_compare(pkg_ver1, pkg_ver2)


    if os_distro == 'ubuntu' or os_distro == 'debian':
        return apt_compare(pkg_ver1, pkg_ver2)

    elif os_distro == 'centos' or os_distro == 'rhel':
        return rpm_compare(pkg_ver1, pkg_ver2)

    logger.warn("unsupported distribution: {}".format(os_distro))
    return 0

class cached_property(object):
    """
    Decorator that converts a method with a single self argument into a
    property cached on the instance.
    """
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, type=None):
        if instance is None:
            return self
        res = instance.__dict__[self.func.__name__] = self.func(instance)
        return res

class MakeScan(object):

    SUPPORTED_UBUNTU_VERSIONS = [ 'saucy', 'quantal', 'precise', 'lucid', 'trusty', 'utopic', 'vivid', 'wily']

    # debian security advisories use code names, crawler uses version numbers
    SUPPORTED_DEBIAN_VERSIONS = { '8': 'jessie', '7': 'wheezy', '6': 'squeeze', '5': 'lenny' }

    def get_version_distro(self, osinfo, namespace, logger, uuid):
        # sample osinfo:
        # osinfo={
        #         "osrelease": "3.13.0-55-generic",
        #         "osplatform": "x86_64",
        #         "osdistro": "CentOS",
        #         "ipaddr": [
        #              "127.0.0.1",
        #              "172.17.1.53"
        #            ],
        #         "osname": "Linux-3.13.0-55-generic-x86_64-with-centos-6.6-Final",
        #         "boottime": 1440524429.0,
        #         "ostype": "linux",
        #         "osversion": "#94-Ubuntu SMP Thu Jun 18 00:27:10 UTC 2015"
        #         }
        # another variation:  osdistro, osname
        #{"osrelease": "3.13.0-55-generic", "osplatform": "x86_64", "osdistro": "CentOS Linux",
        #  "ipaddr": ["127.0.0.1", "172.17.0.63"], "osname": "Linux-3.13.0-55-generic-x86_64-with-centos-7.1.1503-Core",
        #  "boottime": 1441739012.0, "ostype": "linux", "osversion": "#94-Ubuntu SMP Thu Jun 18 00:27:10 UTC 2015"}
        # --> some debian osname can contain release names instaed of releave version
        # Linux-3.13.0-65-generic-x86_64-with-debian-jessie-sid
        if not (osinfo and osinfo.get("osname") and osinfo.get("osdistro") ):
            logger.error('No OS information found for uuid={}, namespace={}, osinfo={}'.format(uuid, namespace, osinfo))
            return None, None

        
        os_name = osinfo["osname"]                 # Linux-3.13.0-55-generic-x86_64-with-Ubuntu-14.04-trusty
                                                   # Linux-3.13.0-55-generic-x86_64-with-centos-6.6-Final
        os_distro = osinfo["osdistro"].lower()     # Ubuntu, CentOS ..

        if 'rhel' in os_distro or 'centos' in os_distro or 'debian' in os_distro:
            if 'rhel' in os_distro:
                os_distro = 'rhel'
            elif 'centos' in os_distro:
                os_distro = 'centos'
            else:
                os_distro = 'debian'

            prefix =  p = osinfo["ostype"]+'-'+osinfo["osrelease"]+'-'+osinfo["osplatform"]+'-with-'+os_distro+'-'
            last_dash = osinfo["osname"].rindex('-')

            if len(p) < last_dash:
                version = osinfo["osname"][len(p):last_dash]
            else:
                version = osinfo["osname"][len(p)]

            full_version = version
            # rhel and centos vulnerabilities seem to use only major version not major.minor
            if '.' in version:
                version = version[:version.index('.')]

            # for debian replace version number with release code name
            if 'debian' == os_distro:
                if version not in self.SUPPORTED_DEBIAN_VERSIONS.values():
                    version = self.SUPPORTED_DEBIAN_VERSIONS[version]

            logger.info("os prefix:{}, full version:{}, version-major:{}".format(prefix, full_version, version))
            return version, os_distro

        elif os_distro == 'ubuntu':
            for d in self.SUPPORTED_UBUNTU_VERSIONS:
                if d in os_name:
                    return d, os_distro
            return None, None
        else:        
            logger.warning('Probably not a known os uuid={}, namespace={}, osinfo={}'.format(uuid, namespace, json.dumps(osinfo)))
            return None, None

    def makeScanForNamespace(self, namespace, timestamp, osinfo, packages, usn_infos, distro_pkg_usn_map, uuid, logger):

        # in cases when crawler fails to crawl a frame it logs error message, 
        # and sends empty frame with just metadata in it. the right behavior is 
        # generate default vulnerability message

        if osinfo is None:
            return [{
                'namespace': namespace,
                'uuid': uuid,
                'timestamp': timestamp,
                'crawled_time': timestamp,
                'description':'Overall vulnerability status',
                'vulnerable': False,
                'total_packages': len(packages),
                'vulnerable_packages':  -1,
                'os_version' : "",
                'os_distrbution' : "",
                'total_usns_for_distro': -1,
                'vulnerable_usns': -1
            }]
            
        vulnerabilities = []
        logger.info ('uuid={}, osinfo={}, namespace={}, package_count={}'.format(uuid, json.dumps(osinfo), namespace, len(packages)))
        os_version, os_distro = self.get_version_distro(osinfo, namespace, logger, uuid)

        if not os_version or not packages:
            vulnerability_summary = {
                'namespace': namespace,
                'uuid': uuid,
                'timestamp': timestamp,
                'crawled_time': timestamp,
                'description':'Overall vulnerability status',
                'vulnerable': False,
                'total_packages': len(packages),
                'vulnerable_packages':  -1,
                'os_version' : os_version,
                'os_distrbution' : os_distro,
                'total_usns_for_distro': -1,
                'vulnerable_usns': -1
            }
            vulnerabilities.append(vulnerability_summary)            
        else:
            vulnerable_pkg_count = 0                        # number of vulnerable package found
            vulnerable_usns = set()                         # usns associated with vulnerable packages
            safe_pkg_count = 0                              # number of packages that have no vulnerabilities
            os_platform = osinfo["osplatform"].lower()    # x86_64  ; usncrawler refers to it as architcture
            # what crawler calls as osplatform, security notices calls as os_archtecture
            # need to sync these up sometime
            if os_distro == 'ubuntu' or os_distro == 'debian':
                os_platform = "" # ubuntu security notices do not include platform info in security notices
                                 # while Red Hat does not

            pkgs_not_found_in_fixes = []
            for pkg_entry in packages:
                key_tuple = (os_distro, os_version, os_platform, pkg_entry['pkgname'])        #  tuple key used in usncrawler (os_distro, os_ver, os_arch, pkg_name)
                fix_data = distro_pkg_usn_map.get(key_tuple, None)
                if fix_data:
                    pkg_ver = pkg_entry['pkgversion']
                    match_index = -1
                    for i in range(len(fix_data)):
                        if compare_versions(os_distro, pkg_ver, fix_data[i].pkg_ver_rel, logger) >= 0:
                            match_index = i
                            break
    
                    usn_list = None
                    #if match_index == -1:
                    #    # we could not find package version in the usn fixes
                    #    # we need to use some heaurstics to deal with this situation
                    #    # we are in the process, for now treat them as safe
                    #    safe_pkg_count = safe_pkg_count + 1
                    #    logger.info('not found in fixes pkg_entry={}'.format(pkg_entry))
                    #    pkgs_not_found_in_fixes.append(pkg_ver)
                    # 
                    #elif match_index == 0:
                    if match_index == 0:
                        # fix package for latest vulnerability, so safe
                        safe_pkg_count = safe_pkg_count + 1
                    else:
                        vulnerable_pkg_count = vulnerable_pkg_count + 1
    
                        fix_pkg_ver = fix_data[0].pkg_ver_rel # top level package fixes all usns
                                                         # this is an assumption
                        if match_index == -1: # not in fixes
                            vulnerable_usn_list = [ fix.id for fix  in fix_data ]
                        else:
                            vulnerable_usn_list = [ fix_data[i].id for i in range(match_index) ]

                        vulnerable_usns |= set(vulnerable_usn_list) 
                        usn_info_list = []
                        for secid in vulnerable_usn_list:
                            usninfo = usndb.sec_notice_map[secid]
                            usn_info_list.append({'usnid':usninfo['id'], 'url': usninfo['site'], 'summary': usninfo.get('summary', 'Could not find summary')})
                        vulnerability_annotation = {
                            'namespace': namespace,
                            'uuid': uuid,
                            'timestamp': timestamp,
                            'crawled_time': timestamp,
                            'vulnerable': True,
                            'package_name': pkg_entry['pkgname'],
                            'current_version': pkg_ver,
                            'fix_version': fix_pkg_ver,
                            'vulnerabilities':  usn_info_list,
                            'os_version' : os_version,
                            'os_distrbution' : os_distro
                        }
                        logger.info('uuid={}, package={}, vulnerability={}'.format(uuid, pkg_entry['pkgname'], vulnerability_annotation))
                        vulnerabilities.append(vulnerability_annotation)
                else:
                    #logger.info('package:{} has no fixes'.format(pkg_entry['pkgname']))
                    pass
                            
            vulnerability_summary = {
                    'namespace': namespace,
                    'uuid': uuid,
                    'timestamp': timestamp,
                    'crawled_time': timestamp,
                    'description':'Overall vulnerability status',
                    'vulnerable': vulnerable_pkg_count>0,
                    'total_packages': len(packages),
                    'vulnerable_packages':  vulnerable_pkg_count,
                    'os_version' : os_version,
                    'os_distrbution' : os_distro,
                    'total_usns_for_distro': usndb.vulnerabilities_by_version.get(os_version),
                    'vulnerable_usns': len(vulnerable_usns)
            }
            vulnerabilities.append(vulnerability_summary)

            logger.info('uuid={}, namespace:{}, usn checked={}, vulnerabilities={}, safe={}'.format(uuid, namespace, len(usn_infos), vulnerable_pkg_count, safe_pkg_count))
            logger.info('uuid={}, packages not found in usn fixes ={}'.format(uuid, pkgs_not_found_in_fixes))

        return vulnerabilities

